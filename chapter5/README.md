# Chapter 5 - Node.js Makes Your Front-end Fly

Note: The chinese book is at: http://bitcoin-on-nodejs.ebookchain.org

Yishu official site: http://ebookchain.org (Wechat group: chainclub)

Translation Cooperation: http://chainmap.org (BlockChain Developer Community) + https://elementus.io/ (Blockchain Data )

Translator/Validator: [Anbei Zhao](https://www.linkedin.com/in/anbei-zhao-b18b48167/), [Christopher Chen](https://www.linkedin.com/in/cchen408/)

Publisher: [George Zhao](https://www.linkedin.com/in/george-zhao-9568865/)


## Preface

This article introduces node.js development environment set-up, the installation and usage of node.js, as well as third-party platforms and resources.
 
This example in this chapter is Statistical Analysis of Cryptocurrency Development Languages (Sacdl) mentioned in the previous article. 
 
## Requirement

The **Sacdl** project requires the following functions:
 
* Easy access to api of the third-party website (in this case, github);
* Data aggregation and pre-processing.
* Data visualization
* Analysis expansion (eg. add more graphics styles or other web apis) later.

## Technology selection

Node.js has many advantages, such as:
 
* Easy to organize: node.js can organize code modularly while js cannot.
* Extensive resources: node. js enables third-party packages, which will bring great convenience.
* Full stack processing: Like ruby on rails, Node.js could merge, compress, confuse and deploy js or CSS files easily. 
 
## Introduction of the Node.js

### What is **node.js**?
 
The official explanation:
 
Node.js® is a JavaScript runtime built on Chrome 's V8 JavaScript engine. Node.js USES an event - driven, non - blocking I/O model that top service it lightweight and efficient.

Node.js® is a platform for you to develop applications in the JavaScript language, and a perfect choice for data-intensive real-time programs running on distributed units.
 
Note that we did not say web application. Many people think node.js can only develop server-centric Web applications. However, Node.js could be applied to PC and mobile, although mostly node.js is applied to web applications, which are great alternatives to traditional Web development such as PHP +apache, JSP +tomcat, ruby on rails + Passenger(or thin) + nginx. Every application written in Node.js could be regarded as a serverware as well as a web application.
 
### What is a data intensive, real-time application?
 
Chat rooms, instant messaging, trading markets (bitcoin, stocks, funds, etc.) and instant trading on e-commerce sites, etc are data intensive, real-time applications. And on Internet, the monitoring and remote control of electrical equipment is another example of data intensive, real-time application.  

### Development steps

#### 1. Build the environment

My personal choice is Ubuntu+Sublime Text;
 
**(1) install node.js**
 
```
Install Nvm
 
$curl - o - https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh | bash
```

Install node.js with Nvm
 
```
$NVM install 5.1.0
The $NVM alias default 5.1.0
```

Version information

* $NVM - v
* $node - v
* $NPM - v

#### 2. Create a project

Create a new folder called "sacdl-project" as the project directory. The path is as follows:
 
/home/yourname/projects/sacdl - project
We usually put the front-end code in the public directory, then set up other directories such as js, CSS and images, and create index.html, js/app.js to display the page and write our js code. 

Under the project folder:

* ` js/a searcher.js ` : search box processing,
* ` js/utils.js `: data processing,
* ` js/bar.js ` : d3 histogram,
* ` js/treemap.js `: tree matrix,
* ` js/app.js `:  integrated user invocation, similar to controller or routing.


Front-end third-party components, such as d3.js, are stored in bower_components and generated automatically by bower. Background third-party modules are put in node_modules and automatically generated by NPM.
 
#### 3. Front-end components

On the command line, enter the project directory above and install the front-end management tool bower

``` 
npm install bower
```

Note: bower is an NPM package that manages web front-end dependencies (including js, CSS,images,fonts, etc.). A simple analogy is that bower is used to manage front-end packages while NPM managing back-end libraries (packages).
 
Initialization

``` 
bower init
```

This will generates a bower. Json file, so our code is managed as a complete front-end component.
 
Install d3.js through bower
 
```
bower install d3 - save

Option --save will write the following information in the bower. Json:
 
"Dependencies" : {
...
"D3" : "~ 3.5.12",
...
}
```

This way, when you use another computer, you can clone the code and run the following command directly, automatically installing all dependent third-party components
 

### 4. Front-end process

According to the requirements above, our process is roughly as follows:

 
1. Accept the request: provide an input box, accept the user input, get the query keyword, and turn it into the api address request of github.com;
2. Data acquisition: processed data through ajax request according to the address.
3. Display data: write chart style with d3.js to display data.


### 5. API

The first step is to provide an input box. Let's get started:
 
Github was developed in ruby on rails, and its API has a typical ror restful style. Here's a piece of official search sample code:
 
https://api.github.com/search/repositories? Q = tetris + language: assembly&sort = stars&order = desc

You can get the data in json format. Officially, we use curl command.
 
This is the original data structure. In most cases, you'll need to rearrange it. We first convert data format for the tree matrix graph:
 
 ```
{
"Name" : "languages",
"Children" : [{
"Name" : "javascript",
"Children" : [{
"Name" : "imfly/myIDE",
"Watchers_count" : 100,
"Forks_count" : 50
}]
}]
}
```
 
### 6. Data collection


Under the public/js folder, we create utils.js and open it with a text editor(For me, Sublime).
 
#### (1) modularize front-end code
 
To implement modular programming, we organize the front-end code in the following format.
 
```
Var Utils = (function () {
// local variable
Var a = 0;
 
// public method
return {
settings: the function () {},
init: function () {},
...
}
 
// private method
function name () {}
} ())
```

We can call it in index.html by:
Utils.init();
This will not work:
Utils.name();

#### (2) convert data format

How to reorganize the data obtained from API? 

```
function getTreeData(dataSet) {
    var languages = {};

    //create a new root node
    var result = {
        "name": "languages",
        "children": []
    }

    // loop through the child nodes
    if (dataSet && dataSet.items) {
        var items = dataSet.items;

        //find out the language involved first
        items.forEach(function(item, index) {
        if (typeof languages[item.language] === "undefined") {
            languages[item.language] = index;
        };
        })

            // sort by language
        for (var language in languages) {

        if (language === "null") {
            language = "others";
        };

        //child nodes of each language
        var root = {
            "name": language,
            "children": []
        };

        // search again from global variables
        items.forEach(function(item, index) {
            var child = {
                "name": item.full_name,
                "watchers_count": item.watchers_count,
                "forks_count": item.forks_count
            };

            if (item.language === language || (item.language === "null" && language === "others")) {
                root.children.push(child);
            };

        })

        result.children.push(root);
        }
    }

    return result;
}
```

Obviously, this is a private method. Because we have to operate data analysis for every chart. We take the above method as the first step, and then cache the resultsas the foundation for following operations (public methods). Please refer to source js/utils.js, click here.

### 7. D3. Js rendering

**(1) understand the d3.js process**

Some people complain d3.js is difficult. In this case, echarts and xcharts  are good alternatives.

The basic process of d3.js is:

In HTML, assign the location of the presentation diagram, usually with div#Id;
Request and populate the data;
Render the diagram, add new elements with append(), and use remove() to remove additional elements;

A quick example:

Add a div element to the test.html page, as follows:

```
< div id = "testId" > < / div >
```

Create a new test.js file and write the following code:

```
// can be obtained dynamically
Var dataset = [1, 2, 3, 4];

// populating the data, usually with the data template provided by d3.layout, and then filling it with the data() method
var chart = d3.select('#testId')
        .selectAll('p')
        .data(dataset, function(d) { return d; });


// render the view
//call  enter () after data ()
chart
.enter()
.append('p')
.text(function(d, i) {
    return [d, i];
})

chart.exit().remove();
```


We provided 4 values of dataset by default. The first rendering will display 4 elements normally. Next, the data dataset is replaced by [5,6], and then the render, the enter() method will get the element originally rendered [1,2] and change its value to [5,6], while the elements in [3,4] position are deleted because there is no data. This enables the graph dynamic transformation.

Note: the d3.layout mentioned above may be surprising for beginners. Layout, as a concept of layers, is often used as a global template file in an HTML view, such as layout.html, layout.ejs, etc. However, here in d3.js, it is applied to data, which provides methods such as d3.layout.treemap(), which is used to calculate and process various chart data, i.e., data template. D3.js process data with append() and remove() to add or remove elements, with .style () to achieve page control. Obviously, this is data-driven.

**(2) render our data**

D3.js provides methods to request data such as d3.json(),d3.csv(), etc. 

Let's take the matrix diagram as an example and add the following elements to index.html

```
< div id = "sacdlTreemap" > < / div >
```

Then write the js/treemap.js to render the diagram.

Finally, in js/app.js, load the data:

```
-- part of the code ----
d3.json(url, function(err, data) {
    if (err) {
    ...
        alert("wrong.")
    };

    Utils.getData(data);

    Treemap.show();

    ...
});
```


-- part of the code ----

See the source code for details.

**(3) viewing effect**

Right-click and choose to open it in the browser. See how it works.

### 8. Code debugging

Ppress F12 on the open browser page and the console window will pop up as follows:

### 9. Deployment and release

In order to improve the page loading speed and user experience, we need to merge and compression code; if you want to protect your work, you need code confusion or  code deployment. 
In the node.js community, grunt and gulp are 2 popular tools. We will use gulp.

#### (1) Principle

The core concept of gulp is pipeline. Designing a task is to build a pipeline, which involves 5 methods:

```
1 > build pipeline and name it with `gulp.task()`,
2 > the pipe inlet method called `gulp.src()` ,
Each pipe section is called ` .pipe () `,
3 > pipe export is called ` gulp.dest () `,
4 > monitoring changes with `gulp.watch`,
5 > Schedule pipelines’ operation with `gulp.run`
```

#### (2) installation

```
CNPM install gulp - global
```

Use --global for global installation so we can use the gulp command in any path.


```
CNPM install gulp - save - dev
```

This is installed in the project directory for easy administration. Also, because gulp is just a development aid and is only used on a local development machine, we should add --save-dev option and installs the gulp module in the development dependency.

#### (3) pipeline construction

Build gulpfile.js manually. 

```
-- other code ----
/ / build a pipeline named ` js `
gulp.task('js', ['clean'], function() {

    return es.merge(                  
            gulp.src(assets.js.vendor)
            .pipe(gulp.dest(settings.destFolder + '/js/')),

            gulp.src(assets.js.paths)
            .pipe(order(assets.js.order))
            .pipe(sourcemaps.init()) 
            .pipe(uglify())  
            .pipe(concat(settings.prefix.destfile + '.js'))
            .pipe(sourcemaps.write())
            .pipe(gulp.dest(settings.destFolder + '/js'))
        )
        .pipe(concat(settings.prefix.mergefile + '.js')) 
        .pipe(gulp.dest(settings.destFolder + '/js/'))   
});
```

On the command line, enter the following command to run the task.

```
gulp deploy
```

#### (4) plug-in

3 gulp plug-in order，sourcemaps,uglify can be found from the official network, other plug-ins involved in project involved are listed below:


```
"Gulp-concat": "^2.6.0", / / merge JS, CSS, etc.

"Gulp-cssnano": "^2.1.0", //compress css.

"Gulp-gh-pages": "^0.5.4", / / deploy to `gh-pages` of GitHub.

"Gulp-imagemin": "^2.4.0", / / image compression

"Gulp-order": "^1.1.1", //order js, CSS, etc.

"Gulp-processhtml": "^1.1.0", / / replace the finished code with template files such as.Html and.Ejs.

"Gulp-sourcemaps": "^1.6.0", / / generate sourcemaps file

"Gulp-uglify": "^1.5.1", / / confuse and compress the JS file.
```

#### (5) deployment


```
var ghPages = require('gulp-gh-pages');

//Deploy
gulp.task('deploy', function() {
    return gulp.src('./dist/**/*')
               .pipe(ghPages());
});
```


Run gulp deploy to run the code


Of course, it is better to run the command of merge and compression before running the deployment command. You could define it in the deployment task as mentioned above. Please refer to the source code here.







